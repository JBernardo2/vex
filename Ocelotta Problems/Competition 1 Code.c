#pragma config(Sensor, in1,    gyro,           sensorGyro)

#pragma config(Motor,  port2,           frontLeftMotor, tmotorServoContinuousRotation, openLoop)

#pragma config(Motor,  port3,           backLeftMotor, tmotorServoContinuousRotation, openLoop)

#pragma config(Motor,  port4,           liftMotor,     tmotorServoContinuousRotation, openLoop, reversed)

#pragma config(Motor,  port6,           shootLeftMotor, tmotorServoContinuousRotation, openLoop)

#pragma config(Motor,  port7,           shootRightMotor, tmotorServoContinuousRotation, openLoop, reversed)

#pragma config(Motor,  port8,           frontRightMotor, tmotorServoContinuousRotation, openLoop, reversed)

#pragma config(Motor,  port9,           backRightMotor, tmotorServoContinuousRotation, openLoop, reversed)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/*---------------------------------------------------------------------------*/

/*                                                                           */

/*        Description: Competition template for VEX EDR                      */

/*                                                                           */

/*---------------------------------------------------------------------------*/



// This code is for the VEX cortex platform

#pragma platform(VEX2)

// Select Download method as "competition"

#pragma competitionControl(Competition)



//Main competition background code...do not modify!

#include "Vex_Competition_Includes.c"



/*---------------------------------------------------------------------------*/

/*                          Pre-Autonomous Functions                         */

/*                                                                           */

/*  You may want to perform some actions before the competition starts.      */

/*  Do them in the following function.  You must return from this function   */

/*  or the autonomous and usercontrol tasks will not be started.  This       */

/*  function is only called once after the cortex has been powered on and    */

/*  not every time that the robot is disabled.                               */

/*---------------------------------------------------------------------------*/



void pre_auton()

{

  // Set bStopTasksBetweenModes to false if you want to keep user created tasks

  // running between Autonomous and Driver controlled modes. You will need to

  // manage all user created tasks if set to false.

  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD

	// used by the competition include file, for example, you might want

	// to display your team name on the LCD in this function.

	// bDisplayCompetitionStatusOnLcd = false;



  // All activities that occur before the competition starts

  // Example: clearing encoders, setting servo positions, ...

}



/*---------------------------------------------------------------------------*/

/*                                                                           */

/*                              Autonomous Task                              */

/*                                                                           */

/*  This task is used to control your robot during the autonomous phase of   */

/*  a VEX Competition.                                                       */

/*                                                                           */

/*  You must modify the code to add your own robot specific commands here.   */

/*---------------------------------------------------------------------------*/



task autonomous()

{
	motor[shootLeftMotor] = 127;

	motor[shootRightMotor] = 127;

	delay(2500);

	motor[shootLeftMotor] = 0;

	motor[shootRightMotor] = 0;

  //turn direction 90

  //go to cap, flip and intake

  //turn 180

  //get back to starting spot

  //turn back to original rotation

  //fire

  //forward for low flag

}

float absoluteDifference(float angle1, float angle2){

	if(abs(angle1-angle2) < 180){

		return abs(angle1-angle2);

	}

	else{

		return 360 - abs(angle1-angle2);

	}

}

float difference(float angle1, float angle2){
	
	if(abs(angle1 - angle2) < 180){

		return angle1 - angle2;

	}

	else{

		return 360 - (angle1 - angle2);

	}

}


void turnToDegrees(float degrees){

	degrees *= 10;

	int margin = 20;

	int basePower = 40;

	float initialGyro = (SensorValue[gyro] >= 0) ? SensorValue[gyro] : SensorValue[gyro] + 3600

	int direction = 0;
	
	if(((initialGyro < degrees) ? initialGyro : degrees) + 1800 > ((initialGyro > degrees) ? initialGyro : degrees)){

		direction = 1;

	}

	else{

		direction = -1;

	}

	



	while(absoluteDifference(((SensorValue[gyro] >= 0) ? SensorValue[gyro] : SensorValue[gyro] + 3600), degrees) < margin){

		float absDiff = absoluteDifference(((SensorValue[gyro] >= 0) ? SensorValue[gyro] : SensorValue[gyro] + 3600), degrees);
		
		float power = basePower + (127 - basePower) * (sqrt(1800) - sqrt(absDiff))/sqrt(1800);

		motor[frontLeftMotor] = -power * direction;

		motor[backLeftMotor] = -power * direction;

		motor[frontRightMotor] = power * direction;

		motor[backRightMotor] = power * direction;

	}

}



void driveStraight(int ms, float degrees){

	ClearTimer (T1);

	degrees *= 10;

	int basePower = 120;

	int turnPower = 120;

	while(time1[T1] < ms){

		float diff = difference(((SensorValue[gyro] >= 0) ? SensorValue[gyro] : SensorValue[gyro] + 3600), degrees);

		motor[frontLeftMotor] = basePower + diff * turnPower;

		motor[backLeftMotor] = basePower + diff * turnPower;

		motor[frontRightMotor] = basePower - diff * turnPower;

		motor[backRightMotor] = basePower - diff * turnPower;

	}

}


task usercontrol()

{

	float maxMotor = 0;

	float frontSpeed = 0;

	float rightSpeed = 0;

	float theta = 0;

	SensorType[gyro] = sensorNone;

	wait1Msec(1000);

	SensorType[gyro] = sensorGyro;

	wait1Msec(2000);

	while(true){

		float motors[4] = {0, 0, 0, 0};

		//float axes[3] = {0, 0, 0);

		motors[0] = vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1];

		motors[1] = vexRT[Ch3] - vexRT[Ch4] + vexRT[Ch1];

		motors[2] = vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1];

		motors[3] = vexRT[Ch3] + vexRT[Ch4] - vexRT[Ch1];



		/*

		theta = SensorValue[gyro]

		frontSpeed = vexRT[Ch3];

		rightSpeed = vexRT[Ch4];

		frontSpeed = frontSpeed*cos(theta) - rightSpeed*sin(theta);

		rightSpeed = rightSpeed*cos(theta) + frontSpeed*sin(theta);

		axes[0] = frontSpeed;

		axes[1] = rightSpeed;

		axes[2] = vexRT[Ch1];

		*/

		maxMotor = 0;



		for(int i = 0; i < 4; i++){

			maxMotor = (motors[i] > maxMotor) ? motors[i] : maxMotor;

		}

		if(maxMotor > 127){

			for(int i = 0; i < 4; i++){

				motors[i] *= 127/maxMotor;

			}

		}



		/*

		for(int i = 0; i < 3; i++){

			maxMotor = (axes[i] > maxMotor) ? axes[i] : maxMotor;

		}

		if(maxMotor > 127){

			for(int i = 0; i < 3; i++){

				axes[i] *= 127/maxMotor;

			}

		}

		*/



		motor[frontLeftMotor] = motors[0];

		motor[backLeftMotor] = motors[1];

		motor[frontRightMotor] = motors[2];

		motor[backRightMotor] = motors[3];



		if(vexRT[Btn5U]){

			motor[liftMotor] = 127;

		}

		else if(vexRT[Btn5D]){

			motor[liftMotor] = -127;

		}

		else{

			motor[liftMotor] = 0;

		}



		if(vexRT[Btn6U]){

			motor[shootLeftMotor] = 127;

			motor[shootRightMotor] = 127;

		}

		else if(vexRT[Btn6D]){

			motor[shootLeftMotor] = -127;

			motor[shootRightMotor] = -127;

		}

		else{

			motor[shootLeftMotor] = 0;

			motor[shootRightMotor] = 0;

		}

	}

}